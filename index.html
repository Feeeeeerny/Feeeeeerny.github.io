<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="十秒's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="十秒's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十秒's blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 十秒's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">十秒's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/Iconfont/" itemprop="url">
                  App中使用Iconfont的整套方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-28T16:30:20+08:00" content="2017-03-28">
              2017-03-28
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是Iconfont"><a href="#什么是Iconfont" class="headerlink" title="什么是Iconfont"></a>什么是Iconfont</h2><p>我们通常看到的图标都是以图片形式集成到项目中使用，而 <code>Iconfont</code> 是一套字体图标，和我们使用自定义字体的方式是一样的，并且它是一种矢量图标。</p>
<p>计算机中显示的图形一般分为两类—位图和矢量图，我们平常使用的JPEG、PNG等图片都是位图格式，是一种由像素来表示的图像，而矢量图是由点、直线、多边形等基于数学方程的几何图元表示的图像，对比位图，矢量图具有体积小，放大缩小都不会失真的优点，这个优点就可以给项目带来很大好处了，但缺点是无法用来表达色彩层次丰富的图像，因此一些色彩复杂的图形仍然需要位图去表达。正巧我们项目在进行模块化，碰到不同模块使用到相同的图片时，尤其是这种基础icon，复制多份到各自的模块中是不太优雅的，利用Iconfont就可以很好的解决。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>缩放不会模糊，告别iOS中2x/3x以及未来nx的问题</li>
<li>一套资源可在web、iOS、Android等多个平台使用</li>
<li>一键换肤、方便更改图片颜色，图片复用</li>
<li>一定程度上减小包体积</li>
<li>有利于项目模块化</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>图标制作/更新成本高</li>
<li>只支持单色</li>
</ul>
<h2 id="如何制作Iconfont"><a href="#如何制作Iconfont" class="headerlink" title="如何制作Iconfont"></a>如何制作Iconfont</h2><p>首先，你得拥有一套完美的图标库，如下图，这里我们选用Sketch为容器去维护这些图标，毕竟对程序员来说是比较容易上手的工具，注意矢量图的制作还是需要设计师的哦，不然有的是坑让你踩的。不管使用AI还是其他什么矢量图绘制软件制作的图标我们最终都放入这个文件中，后续的更新也是往后面逐一增加。</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/iconfont" alt="iconfont"></p>
<p>可以看出来，其实都是一些基础通用icon，这些icon复用率非常高，如果你们公司有多个App，复用这一个字体文件就可以快速使用图标而不需要各种拷贝图片资源了。我们最终需要的是一个包含所有图标的字体文件即ttf文件，使用过自定义字体的开发者应该都知道ttf（TrueType font），我们在电脑上是可以直接双击ttf文件安装字体使用的。如下图</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/zan-iconfont" alt="zan-iconfont"></p>
<p>那么如何将这些矢量图标最终合并为一个字体文件呢？</p>
<h3 id="将sketch中的图标导出"><a href="#将sketch中的图标导出" class="headerlink" title="将sketch中的图标导出"></a>将sketch中的图标导出</h3><p>上面说了有矢量图和位图之分，那么位图就是平常我们导出的后缀为png、jpeg、gif这种格式的，矢量图一般有.ai，.pdf，.svg等等，这里我们导出为svg格式。Bohemian Coding(Sketch的制作团队)发布过一款名为 <strong><a href="https://www.sketchapp.com/tool/" target="_blank" rel="external">SketchTool</a></strong> 的命令行工具，用来自动导出 <code>.sketch</code> 文件当中的界面和切片。如果你愿意手动一张张导出也可以，我敬你是条汉子~</p>
<p>安装好 <code>sketch</code> 后，在命令行中执行如下命令安装 <code>sketchtool</code> (换成你自己的路径)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh /Applications/Sketch.app/Contents/Resources/sketchtool/install.sh</div></pre></td></tr></table></figure></p>
<p>我们通过下面的命令批量导出图标，其中 <code>${SRCROOT}/../ZanIconFont/Icon/icons.sketch</code> 替换成你的 <code>iconfont.sketch</code> 的路径，<code>${SRCROOT}/../ZanIconFont/Icon/svg</code> 替换成你的导出目标路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sketchtool export slices $&#123;SRCROOT&#125;/../ZanIconFont/Icon/icons.sketch --output=$&#123;SRCROOT&#125;/../ZanIconFont/Icon/svg --formats=svg</div></pre></td></tr></table></figure>
<p><code>export slices</code> ：导出切片，这个跟sketch中的设置相关，我们这里每一个图标设置成了slice，所以对应的命令使用的是 export slices，如果每个图标都有自己的artboard，那么就是 export artboards。<br><code>--format=svg</code> ：导出为svg格式。</p>
<p>sketchtool相关的命令以及参数我们都可以通过在命令行中输入sketchtool来查看，这里就不细说啦。导出的部分svg图片如下：</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/svgs" alt=""></p>
<h3 id="合成ttf字体文件"><a href="#合成ttf字体文件" class="headerlink" title="合成ttf字体文件"></a>合成ttf字体文件</h3><p>我们需要将上述所有svg图片合并为一个ttf，这里我们使用的是内部前端组开发的一个命令行工具 <strong><a href="https://github.com/youzan/iconfount" target="_blank" rel="external">iconfount</a></strong>，已经开源，安装以及详细说明可以在github上看到。</p>
<p>在命令行中执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconfount --found-config.js</div></pre></td></tr></table></figure></p>
<p>其中 <code>found-config.js</code> 是你的配置文件，支持js或者json，在iconfount项目的sample/目录下有个示例配置文件，可以参考。看下我们的配置文件部分截图：</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/configfile" alt="configfile"></p>
<p><code>name</code>：字体名称（familyName），就是后续代码中注册字体用到的。<br><code>output</code>：输出字体、样式以及示例文件的目录，可以是相对路径或者绝对路径<br><code>glyphs_dir</code>：存放svg文件的根目录，就是上一步生成的svg目录。<br><code>glyphs</code>：所有图标的定义，每个图标都有keywords、src等等若干其他属性，我们这里只需要使用src属性即可。最好与项目中每个图标的name保持一致。</p>
<p>其他的参数在github上都有详细说明，这里就不一一列举啦。</p>
<p>最终会生成如下一些文件</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/iconfonttypes" alt="iconfontfile"></p>
<p>可以看到在font文件夹中已经包含了ttf，另外还有woff、eot等其他类型，这些都是用于web端的，对于App可以先不用管。我们再看到有个demo.html如下，列举了图标列表，点击右上角show codes可以查看对应的编码。我们在项目中使用iconfont时是需要依赖这个demo.html的可视化界面的，否则你不知道编码所对应的图标是长什么样子的。</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/iconfont-html" alt=""></p>
<p>以上是生成ttf字体文件的整个流程，而另外也有很多优秀的平台提供整套功能，例如 <strong><a href="http://iconfont.cn/" target="_blank" rel="external">Iconfont</a></strong>，<strong><a href="https://icomoon.io/#home" target="_blank" rel="external">icomoon</a></strong>，<strong><a href="http://fontello.com/" target="_blank" rel="external">fontello</a></strong>  等等，这些平台都提供了很多成熟的图标集，支持在线导入自定义的SVG图标，生成样式、字体文件等等一整套方案，关于这些平台的使用这里不再赘述，各个官网以及很多文章都有很详细的说明。但是我们考虑到的是后期维护更新还是比较麻烦，如果更新图标需要重新导入到平台上、生成字体文件、再引入项目，每次需要手动去完成。因此产生了 <strong><a href="https://github.com/youzan/iconfount" target="_blank" rel="external">iconfount</a></strong>，他是基于fontello、使用了很多fontello的代码和库而开发一个命令行工具，能够很好的整合到项目中完成自动化，后续图标更新了，设计师只要更新图标本身即可，而我们的Iconfont库重新build一遍即可完成所有的操作。这里iOS使用了Cocoapods去管理Iconfont私有库，因此每次更新图标后Iconfont库的开发者去更新下sketch整个文件，重新build一遍就会自动去执行导出svg图标、生成字体文件的脚本，业务方升级一下版本即可。</p>
<h2 id="在App中使用"><a href="#在App中使用" class="headerlink" title="在App中使用"></a>在App中使用</h2><h3 id="在iOS中使用"><a href="#在iOS中使用" class="headerlink" title="在iOS中使用"></a>在iOS中使用</h3><p>先看下简单的demo</p>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/icondemo" alt="icondemo"></p>
<p>首先把上面制作的ttf字体文件引入到项目中，代码中注册字体，打印出来是可以找到你的字体的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)registerFontWithURL:(<span class="built_in">NSURL</span> *)url &#123;</div><div class="line">    <span class="built_in">NSAssert</span>([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[url path]], <span class="string">@"Font file doesn't exist"</span>);</div><div class="line">    <span class="built_in">CGDataProviderRef</span> fontDataProvider = <span class="built_in">CGDataProviderCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)url);</div><div class="line">    <span class="built_in">CGFontRef</span> newFont = <span class="built_in">CGFontCreateWithDataProvider</span>(fontDataProvider);</div><div class="line">    <span class="built_in">CGDataProviderRelease</span>(fontDataProvider);</div><div class="line">    <span class="built_in">CTFontManagerRegisterGraphicsFont</span>(newFont, <span class="literal">nil</span>);</div><div class="line">    <span class="built_in">CGFontRelease</span>(newFont);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">UIFont</span> familyNames]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用场景：</p>
<h4 id="as-text"><a href="#as-text" class="headerlink" title="as text"></a>as text</h4><p>是字体文件的一般用法，代码如下。但是这种方式在替换原来的图标过程中会改变添加控件的方式，原本都是用UIImageView图片控件而现在要改成UILabel或其他文本控件了，所以这边我们推荐使用第二种。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">label.attributedText = [ZanIconFont attributedStringWithIcon:zicon_edit fontSize:<span class="number">20</span> color:[<span class="built_in">UIColor</span> redColor]]</div></pre></td></tr></table></figure>
<p>部分实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSAttributedString</span> *)attributedStringWithIcon:(ZanIconName)iconName fontSize:(<span class="built_in">CGFloat</span>)fontSize color:(<span class="built_in">UIColor</span> *)color</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIFont</span> *font = [<span class="keyword">self</span> fontWithSize:fontSize];</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *attributed = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:@&#123;<span class="built_in">NSFontAttributeName</span>:font&#125;];</div><div class="line">    <span class="keyword">if</span> (color) &#123;</div><div class="line">        [attributed setObject:color forKey:<span class="built_in">NSForegroundColorAttributeName</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSAttributedString</span> alloc] initWithString:iconName attributes:attributed];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="as-image"><a href="#as-image" class="headerlink" title="as image"></a>as image</h4><p>我们采用Category的方式对UIImageView增加设置图片的方法，同时也可以对UIButton、UILabel等其他控件增加Category。这里会去读取UIImageView控件的bounds作为image的size。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.imageView setImageWithIcon:zicon_edit];</div></pre></td></tr></table></figure></p>
<p>也可以自定义image的size、fontSize、tintColor等属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *image = [ZanIconFont imageWithIcon:zicon_edit imageSize:<span class="built_in">CGSizeMake</span>(<span class="number">30</span>, <span class="number">30</span>) fontSize:<span class="number">20</span> tintColor:[<span class="built_in">UIColor</span> redColor]];</div></pre></td></tr></table></figure></p>
<p>部分实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIImage</span> *)imageWithIcon:(ZanIconName)iconName imageSize:(<span class="built_in">CGSize</span>)imageSize fontSize:(<span class="built_in">CGFloat</span>)fontSize tintColor:(<span class="built_in">UIColor</span> *)tintColor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!iconName) &#123;</div><div class="line">        <span class="built_in">NSAssert</span>(iconName, <span class="string">@"icon object should not be nil, check if the font file is added to the application bundle and you're using the correct font name."</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageSize, <span class="literal">NO</span>, [<span class="built_in">UIScreen</span> mainScreen].scale);</div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *fontString = [ZanIconFont attributedStringWithIcon:iconName fontSize:fontSize color:tintColor];</div><div class="line">    <span class="built_in">CGSize</span> iconSize = [fontString size] ;</div><div class="line">    <span class="built_in">CGFloat</span> xOffset = (imageSize.width - iconSize.width) / <span class="number">2.0</span>;</div><div class="line">    <span class="built_in">CGFloat</span> yOffset = (imageSize.height - iconSize.height) / <span class="number">2.0</span>;</div><div class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(xOffset, yOffset, iconSize.width, iconSize.height);</div><div class="line">    [fontString drawInRect:rect];</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *iconImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="keyword">return</span> iconImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也支持在Storyboard上设置icon name，通过Category对UIImageView增加IBInspectable类型的 <code>iconName</code>属性，匹配iconNameString对应的Unicode。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImageView</span> (<span class="title">ZanIconFont</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setIconName:(<span class="built_in">NSString</span> *)iconNameString</div><div class="line">&#123;</div><div class="line">    ZanIconName iconName = [ZanIconFont iconNameWithString:iconNameString];</div><div class="line">    <span class="keyword">if</span> (!iconName) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> setImage:[ZanIconFont imageWithIcon:iconName imageSize:<span class="keyword">self</span>.bounds.size tintColor:<span class="keyword">self</span>.tintColor]];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><img src="http://oni8sc1xh.bkt.clouddn.com/imageViewCategory" alt="imageViewCategory"></p>
<h3 id="在Android中使用"><a href="#在Android中使用" class="headerlink" title="在Android中使用"></a>在Android中使用</h3><p>可参考开源库 <a href="https://github.com/JoanZapata/android-iconify" target="_blank" rel="external">iconify</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>起初Iconfont在web中使用比较流行，在App中使用较少，但是目前看来很多大厂的App也纷纷使用起来，Iconfont的接入给我们项目带来了很多的方便，同时也可以解决我们在模块化过程中不同模块之间重复图片的问题，总之利大于弊，小伙伴们赶紧用起来吧。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="external">http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html</a><br><a href="https://github.com/dzenbot/Iconic" target="_blank" rel="external">https://github.com/dzenbot/Iconic</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/28/Universal Links/" itemprop="url">
                  Universal Links
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-28T12:20:40+08:00" content="2016-10-28">
              2016-10-28
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当你的iOS应用支持 <code>universal link</code> 功能，iOS用户可以点击这个链接不用经过safari就可以直接打开你的App（已经被安装的），如果你的App没有被安装，则会在safari打开这个链接。</p>
<p><code>Universal link</code> 给予你几个关键词，让你不用再使用 <code>URL schemes</code>.<br><code>Unique</code>：不像自定义的 <code>URL schemes</code>, <code>Universal link</code> 不能被其他apps声明，因为这是指向你的website的标准HTTP或者HTTPS链接。<br><code>Secure</code>：当用户安装了你的app，iOS系统会检查那个你向你的web服务器上传的 <code>一个文件</code>，他是用来确保你的网站允许你的App去打开这些代表它的urls。只有你可以创建和上传这个文件，所以你的网站关联到你的App是安全的。<br><code>Flexible</code>：当你的app没有被安装，<code>Universal link</code>也是起作用的。当你点击这个link时他会在safari中打开。<br><code>Simple</code>：这个link同时起作用与打开你的网站或者你的app。<br><code>Private</code>：其他的app可以直接打开你的app，而不需要知道你的app是否安装。</p>
<blockquote>
<p>注意<br>当用户在 <code>WKWebview</code>、 <code>UIWebView</code> 和 <code>Safari</code> 中打开这个link时，<code>Universal link</code>会直接打开你的app，除了使用 <code>openURL:</code>去打开这个link。例如那些发生在打开Mail、Messages或者其他app。<br>当一个用户正在safari中浏览你的网站并且他们在当前网页相同域名下点击了一个universal link，iOS系统会认为这个用户的最大可能性的意图是在safari中打开这个link。而如果用户在不同的域名下点击了这个universal link，那么iOS系统则会打开你的app。<br>对于那些还在使用iOS9.0系统一下的用户，点击universal link会在safari中打开你的网站。</p>
</blockquote>
<p>支持 <code>Universal link</code> 非常简单。以下三个步骤：</p>
<ul>
<li>创建一个名为 <code>apple-app-site-association</code> 的文件，这个文件包含了能被你的app所处理的 <code>JSON</code> 数据。</li>
<li>上传这个文件到你的 <code>HTTPS web server</code>。你可以将文件放在你服务器的根目录下或者 <code>.well-known</code> 子目录下。</li>
<li>让你的app去准备处理这些 <code>universal link</code>。<br>必须在真机下测试 <code>universal link</code>。</li>
</ul>
<h2 id="创建和上传Association-Fille"><a href="#创建和上传Association-Fille" class="headerlink" title="创建和上传Association Fille"></a>创建和上传Association Fille</h2><p>为了在你的网站和你的app之间创建一个安全的连接，你必须在他们之间建立一个可信任的关系。以下两步：</p>
<ul>
<li>上传到你的网站的 <code>apple-app-site-association</code> 文件。</li>
<li>在你的app中添加 <code>com.apple.developer.associated-domains</code> entitlement。（这部分会在下面说到）<br>你可以在<a href="https://developer.apple.com/reference/security/shared_web_credentials" target="_blank" rel="external">Shared Web Credentials Reference</a>中学习到更多关于app如何和网站共享资源的知识。</li>
</ul>
<blockquote>
<p>NOTE<br>If your app runs in iOS 9 or later and you use HTTPS to serve the apple-app-site-association file, you can create a plain text file that uses the application/json MIME type and you don’t need to sign it. If you support Handoff and Shared Web Credentials in iOS 8, you still need to sign the file as described in Shared Web Credentials Reference.</p>
</blockquote>
<p>你需要为你的每一个域名都提供各自的 <code>apple-app-site-association</code> 文件。例如，<code>apple.com</code> 和 <code>developer.apple.com</code> 需要不同的 <code>apple-app-site-association</code> 文件，因为这些域名服务了不停的内容。而相比之下，<code>apple.com</code> 和 <code>www.apple.cm</code> 不需要不同的文件，因为这两个域名是服务同一个内容的，但是这两个域名都不许要使文件有效。对于那些跑在 iOS 9.3.1以及之后的apps，这个文件的大小不能超过128k，不管它是否被signed。</p>
<p>在你的 <code>apple-app-site-association</code> 文件中，你需要区分你网站链接的path，哪些是应该被处理成universal link，而哪些是不应该被处理成universla link的。保证path尽可能的短并且最大程度的支持更多的paths（扩展性）。下面代码是一个 <code>apple-app-site-association</code> 文件中需要被处理成universal link的三个paths。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;applinks&quot;: &#123;</div><div class="line">        &quot;apps&quot;: [],</div><div class="line">        &quot;details&quot;: [</div><div class="line">            &#123;</div><div class="line">                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,</div><div class="line">                &quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;/videos/wwdc/2015/*&quot;]</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,</div><div class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>NOTE<br>不要加.json的扩展名。</p>
</blockquote>
<p><code>apps</code> key必须写并且他的value一定要是一个空的array。<code>details</code> key 是一个包含dictionaries的array，每一个app支持一个dictionary。dictionary的顺序决定了系统查找的顺序，因此你可以指定使用app去处理你的网站链接的某个特殊部分。</p>
<p>每一个dictionary包含了一个 <code>appID</code> 和 <code>paths</code>的key。appID的值是由team ID或者app ID作为前缀，然后紧接着bundle ID组成。paths的值是一个包含了一系列的字符串的array，这些字符串可以是你的网站链接的一部分，专门用作给app处理的，也可以是专门不想给app处理的。如果想要说明不能被处理成Universal link，只需要在path前面加上 <code>NOT</code> 即可。例如，我们可以把上面例子中的 <code>/videos/wwdc/2010/*</code> 变成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;NOT /videos/wwdc/2010/*&quot;, &quot;/videos/wwdc/201?/*&quot;]</div></pre></td></tr></table></figure></p>
<p>因为系统去评估每一个path是按照顺序来的，所以当匹配到正面的或者负面的path时，就停止后续的检查了，所以你应该将高优先级的path放到低优先级的path前面。注意，只有URL中的path组件才会被比较。其他的组件，例如query或者fragment标识都会被忽略。</p>
<p>这里有很多种方法去具体说明在文件中的paths，例如：</p>
<ul>
<li>使用 <code>*</code> 去说明整个网站</li>
<li>包含一个特定的URL，例如 <code>/wwdc/news</code>，去说明一个特定的link</li>
<li>在一个特定URL后拼接 <code>*</code>，例如 <code>/videos/wwdc/2015/*</code>，去说明你网站的一个组<br>除了使用 <code>*</code> 去匹配任意的substring，也可以使用 <code>?</code> 去匹配任意的单个字符。你可以结合使用这两个符号去表达一个path，例如 <code>/foo/*/bar/201?/mypage</code>。</li>
</ul>
<blockquote>
<p>NOTE<br>你用来标识网站的paths应该是极其敏感的。</p>
</blockquote>
<p>当你创建完 <code>apple-app-site-association</code> 文件，上传到你的HTTPS web server的根目录下或者.well-known子目录下。这个文件需要通过HTTPS的链接例如 <code>https://&lt;domain&gt;/apple-app-site-association</code> 或者 <code>https://&lt;domain&gt;/.well-known/apple-app-site-association</code> 并且不会被重定向的去连接下载。然后你需要在你的app中处理universal link。</p>
<h2 id="app处理universal-link"><a href="#app处理universal-link" class="headerlink" title="app处理universal link"></a>app处理universal link</h2><p>Universal link使用了两个技术点：第一个是在浏览器和app之间使用了相同的路径（机制），第二个是Shared Web Credentials（更多的信息查看<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW10" target="_blank" rel="external">Web Browser–to–Native App Handoff</a>和<a href="https://developer.apple.com/reference/security/shared_web_credentials" target="_blank" rel="external">Shared Web Credentials Reference</a>）。当一个用户点击了universal link，iOS会启动你的app并且发送一个 <code>NSUserActivity</code> 对象，你的app可以可以从这个对象中解析app是怎么被启动的。</p>
<p>为了让你的app支持universal link，遵循下面几个步骤：</p>
<ul>
<li>添加你的app所支持的域名</li>
<li>当收到 <code>NSUserActivity</code> 对象时，你的app应当去处理它。</li>
</ul>
<p>在你的 <code>com.apple.developer.associated-domains</code> entitlement中，包含了一些列需要被当做universal link来处理的域名。你可以在xcode中的 <code>Capabilities</code> tab中，添加一个入口去搜索那些你的app所支持的域名，以 <code>applinks:</code> 为前缀，例如 <code>applinks:www.mywebsite.com</code>。这个域名个数限制在20-30个。</p>
<p>为了匹配子域名，你可以在域名的最前面使用 <code>*</code> 通配符（前缀applinks是必须的）。举个例子，如果你使用了 <code>applinks:*.mywebsite.com</code> 和 <code>applinks:*.users.mywebsite.com</code>，那么在匹配 <code>emily.users.mywebsite.com</code> 这个域名的时候会优先去查找 <code>*.users.mywebsite.com</code> 这个入口。注意 <code>*.mywebsite.com</code> 和 <code>mywebsite.com</code> 是不一样的因为星号的前缀。为了使这两个域名都有效，你需要分别设置这两个入口。</p>
<p>设置完以上，去实现 <code>UIApplicationDelegate</code> 的 <code>application:continueUserActivity:restorationHandler:</code> 方法，这样你的app就可以接收universal link并且去处理它了。</p>
<p>当iOS通过用户点击universal link去启动你的app后，你的app会接受到 <code>NSUseractivity</code> 对象，它包含一个值为 <code>NSUserActivityTypeBrowsingWeb</code> 的 <code>activityType</code> 属性。这个对象的 <code>webpageURL</code> 属性包含了用户点击的URL。这个URL总是一个HTTP或者HTTPS的URL，你可以通过 <code>NSURLComponents</code> 的APIs去解析他。</p>
<p>iOS会去检查用户最近的行为，然后去决定当用户点击了universal link后是直接打开app还是继续打开这个网站。例如，一个用户通过点击universal link打开了你的app，但是又点击了状态栏右上角的breadcrumb按钮回到了safari去浏览这个link，当用户做了这个行为，iOS会认为这个用户希望在safari中打开universal link而不是打开app，直到用户在网页中通过点击上面的Banner中的OPEN按钮去打开你的app。</p>
<blockquote>
<p>If you instantiate a SFSafariViewController, WKWebView, or UIWebView object to handle a universal link, iOS opens your website in Safari instead of opening your app. However, if the user taps a universal link from within an embedded SFSafariViewController, WKWebView, or UIWebView object, iOS opens your app.</p>
</blockquote>
<p>确保你的app是否使用了 <code>openURL:</code> 去打开一个universal link是很重要的，在这种场景下，iOS会辨识出唤起universal link的源头是来自你的app，那么因此你的app不应该将他处理成一个universal link，而是一个正常的link去打开。</p>
<p>如果你接收到了一个无效的URL，你应该优雅的去展示这个失败。你可以使用 <code>openURL:</code> 去处理一个不被支持的URL。如果不使用这个，你可以展示一个错误页面。<a href="https://dazhuji.com/index.html" target="_blank" rel="external">测dsad试跳转</a></p>
<blockquote>
<p>为了保护用户的隐私和安全，你不应该使用HTTP链接去传输一些数据，而是使用安全的传输协议例如HTTPS。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/iOS-启动流程/" itemprop="url">
                  iOS:App启动流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T19:30:20+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们一般知道 App 程序入口从执行main函数开始，但其实在main函数之前程序做了很多工作。我们看下面这个图：</p>
<p><img src="http://7xsohh.com2.z0.glb.clouddn.com/%E5%86%85%E6%A0%B8.png" alt="tupian"></p>
<p>从图中我们可以看到执行 main 函数之前大概有两部分先要完成。一部分是 Kernel 内核干的事情，图中列举了些关键节点，详细流程可参考<a href="http://oncenote.com/2015/06/01/How-App-Launch/" target="_blank" rel="external">这篇文章</a>，从<code>设置线程入口-dyld</code>开始就是第二部分动态链接器干的事情。</p>
<h3 id="Kernel内核启动"><a href="#Kernel内核启动" class="headerlink" title="Kernel内核启动"></a>Kernel内核启动</h3><p>简单来说，App由系统内核引导启动，Kernel内核做好所有准备最后会得到线程入口点（main入口），但是线程并不会立即进入这个入口点，这是因为我们还会加载动态链接器（dyld），dyld会先将此入口点保存下来，再设置入口点为 dyld 的入口，等到动态链接器加载完所有库等工作之后再将入口点设置回去，然后程序开始执行main函数。<a href="https://dazhuji.com/index.html" target="_blank" rel="external">测dsad试跳转</a></p>
<h3 id="动态链接器（dyld）"><a href="#动态链接器（dyld）" class="headerlink" title="动态链接器（dyld）"></a>动态链接器（dyld）</h3><ol>
<li><p><strong>加载动态库</strong><br> <code>dyld</code> 是apple的动态链接器，iOS中所有系统 framework 都是动态链接的，在执行我们写的代码之前，动态链接器需要加载完所有动态库的准备工作。</p>
<p> 这个是在 Xcode 中看到的 Link 列表</p>
<p> <img src="http://7xsohh.com2.z0.glb.clouddn.com/%E5%8A%A8%E6%80%81%E5%BA%93.png" alt=""><br> 这些framework将会在动态链接过程中被加载。</p>
<p> 系统使用动态链接库有几点好处：</p>
<ul>
<li>代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中中只有一份</li>
<li>易于维护：由于被依赖的lib是程序执行时才link的，所以这些lib很容易做更新。</li>
<li><p>减少体积：相比静态链接，可执行文件的体积要小很多</p>
<p>我们在 <code>_objc_init</code>（runtime初始化）处打个断点，在程序运行很早的时候断住，看到栈底 <code>_dyld_start</code> 方法，继而调用 <code>dyld::main()</code> 方法，其中完成了上面所说的加载动态库的过程。dyld是开源的，<a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">github地址</a>，有兴趣可以从源码一探究竟。</p>
<p><img src="http://7xsohh.com2.z0.glb.clouddn.com/%E6%A0%88.png" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>共享缓存</strong></p>
<p> 当构建一个程序时，将会链接各种各样的库，他们又会依赖一些其他的 framework 和动态库，需要加载的动态库将会非常多，这样解析会花掉很多时间，一般是好几秒钟，因此为了缩短这个时间，在OS X和iOS上动态链接器使用了共享缓存，共享缓存位于/var/db/dyld/。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 <code>Mach-O</code> 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 共享缓存 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这样就大大优化了 OS X 和 iOS 上程序的启动时间。</p>
</li>
<li><p><strong>加载类、方法等符号</strong></p>
<p> 这里我们用到上图栈中的 <code>ImageLoader</code> ，但是这里的image不是图片的意思，而是一个二进制文件，里面是被编译过的符号、代码等。所以ImageLoader作用是将这些文件加载进内存，且每一个文件对应一个 ImageLoader 实例来负责加载。简单的说 <code>ImageLoader</code> 和 <code>dyld</code>，<code>runtime</code> 配合将类加载进内存，调用顺序:</p>
<ul>
<li>dyld开始将程序二进制文件初始化</li>
<li>交由ImageLoader读取image，其中包含了我们的类、方法等各种符号</li>
<li>由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理</li>
<li><p>runtime接手后调用 <code>map_images</code> 做解析和处理，接下来 <code>load_images</code> 中调用 <code>call_load_methods</code> 方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法</p>
<p>至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）</p>
</li>
</ul>
</li>
<li><p><strong>+load 和+initialize</strong></p>
<p> 上面提到 runtime 回调处理 image 时，会遍历所有加载进来的Class，调用 Class 的 load 方法，那么可以知道，所有 Class 的 load 方法都是在 main 函数之前被调用的，且只会被调用一次。注意，这里调用 load 方法是直接使用函数内存地址 <code>(*load_method)(cls,SEL_load)</code> ，而不是使用发送消息 <code>objc_msgSend</code> 的方式，所以如果子类没有实现 load 方法，那么也不会去调用父类的 load 方法的。<br>+initialize 方法是在类或它的子类收到第一条消息之前调用的，就是说可能永远不会被调用。调用这个方法是使用 objc_msgSend 的，所以子类若未实现该方法，会调用父类的方法。<br>关于这两个方法网上资料很多，可参考源码和雷神的<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">这篇文章</a></p>
</li>
</ol>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>所有初始化等工作完成之后终于来到main函数。</p>
<pre><code>1. 执行main函数中的UIApplicationMain()方法
2. 创建UIApplication对象
3. 创建UIApplicationDelegate对象，并且设置他为UIApplication对象的代理。
4. 创建runloop主循环，代理对象开始监听事件
5. 启动完毕会调用didFinishLaunching，并在该方法中创建UIWindow
6. 设置UIWindow的根控制器，如果有SB，会根据info.plist中指定的入口来加载箭头所指的控制器。
7. 显示窗口。
</code></pre><h3 id="启动时类的方法调用顺序"><a href="#启动时类的方法调用顺序" class="headerlink" title="启动时类的方法调用顺序"></a>启动时类的方法调用顺序</h3><p>额，最后先贴张类的方法调用顺序，忘记了可以看看 = =</p>
<p><img src="http://7xsohh.com2.z0.glb.clouddn.com/%E7%B1%BB%E6%96%B9%E6%B3%95%E9%A1%BA%E5%BA%8F.png" alt=""></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/08/30/objc-pre-main/</a><br><a href="http://oncenote.com/2015/06/01/How-App-Launch/" target="_blank" rel="external">http://oncenote.com/2015/06/01/How-App-Launch/</a><br><a href="http://www.cnblogs.com/dsxniubility/p/4322525.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4322525.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="十秒" />
          <p class="site-author-name" itemprop="name">十秒</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十秒</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
